module.exports = function(io) {

    var ent = require('ent');
	
	var games = []; // Contain all the infos about the games. It's an Array
	
	var chess =  require('../../public/lib/chess.js');
	var gamer_object =  require('../game_handlers/gamer_object.js');
	var game_object =  require('../game_handlers/game_object.js');
	var chess_ai =  require('../../public/lib/chess_ai/chess_ai.js');

    var chess_socket = io.of('/games/chess');
    chess_socket.on('connection', function (socket) {
		socket.on('join', function(room) {
			
			socket.join(room);
			console.log( socket.request.user.username + ' connected to chess lobby');
			
			socket.player = new gamer_object.Gamer(socket, socket.request.user.username);
			
			var game = find_game(room);
			if (game == null) {
				// we create it
				console.log('premier joueur');
				
				game = new game_object.Game(new chess.Chess(), room, socket.player.NAME, 2);
				game.add_user(socket.player);
				games.push(game);
				
				socket.emit('wait');
			} else {
				// we join it
				game.add_user(socket.player);
				
				// Change this later
				console.log('pret a jouer');
				socket.to(room).emit('ready');
			}
		
			
			
			// We inform the other users
			socket.to(room).emit('new_client', socket.request.user.username); // Be aware of script and html !! i need to verify they are not executed

			
			socket.on('message', function (message) {
				// When we get a new messages, we broadcast the author's pseudo, and the message
				socket.broadcast.to(room).emit('message', {username: socket.request.user.username, message: ent.encode(message)});
			});

			
					
			
			socket.on('start_game', function() {
				// TODO : Move some parts to the game object side
				console.log(game.get_status());
				if (game.get_status() == "ready" ) {
					var users = game.get_users();
					var teams = game.process().get_teams();
					var list = [];
					var len = users.length;
					for (var i = 0; i < len; i++) {
						var user = users[i];
						if (user.get_status() === "player" ) {
							user.set_team(teams[i]);
							list.push({name: user.NAME, team:  user.get_team()});
						};
					};
					game.start();		
					socket.to(room).emit('start');
					socket.emit('start', list);
				};
			});
			
				// Called when the client calls socket.emit('move')
			socket.on('move', function(data) {
				console.log(game.get_status());
				console.log("move");
				if ( game.get_status() != 'ongoing' ) {
					console.log(socket.player.NAME + " a voulu jouer sans que la partie soit demarrÃ©e");
					socket.emit('forbidden', 'The game has not started yet');
				} else {
					console.log("Turn : " + game.process().turn());  // NEED TO USE THIS NOTATION
					
					console.log("Player is : " + socket.player.get_team() );
					if ( game.process().can_play( socket.player.get_team() ) ) {
						
						var move = game.process().move( data );
				
						
						if (move === null)  {
							socket.emit('forbidden', 'That move is forbidden.');
						} else {
							console.log('moved');
							socket.to(room).emit('move', game.process().fen());
							
							var finished = game.process().game_over();
							
							if( finished ) {
								if( game.process().in_draw() ) {
									console.log('it is a draw');
									socket.to(room).emit('game_ended', 'The game has ended : it s a draw');
									socket.emit('game_ended', 'The game has ended : it s a draw');
								}
								else {
									console.log('someone won');
									socket.to(room).emit('game_ended', 'The game has ended : someone won');
									socket.emit('game_ended', 'The game has ended : someone won');
								}
							}
							else {
								
								var depth = 3;							
								var bestMove = chess_ai.minimaxRoot(depth, game.process(), true);
							
								
								// Emit the move generated by IA to the ONLY player
								console.log( game.process().fen() );
								
								game.process().ugly_move(bestMove);
								socket.emit('move', game.process().fen());

								console.log( game.process().fen() );
								
								console.log("The AI has played");
								
							}
												
						};
					} else {
						socket.emit('undo'); //Temporary solution
						socket.emit('forbidden', "It's not your turn.");
					};
				};
			});
			
			
			
			socket.on('test', function() {

				
				console.log( game.process().moves() );
				
			});			
			
			socket.on('reset', function () {
				console.log('someone want to reset')
				game.process().reset();
				socket.emit('reset');
				socket.to(room).emit('reset');
			});
			
			
			
			socket.on('surrender', function() {
				console.log("TODO : Surrender de " + socket.request.user.username)
				// TO DO
				
			});
			
			socket.on('play_against_AI', function() {
				console.log('smn wants to play against ai.');
				// Si y'a pas tout les joueurs :
				
				if (game.get_status() == "waiting" ) {
					var ai_player = new gamer_object.Gamer(null, "AI player", "ai");
				
					game.add_user(ai_player);
					socket.emit('ready');
				
				};
			});
			
			
			socket.on('disconnect', function () {
				console.log(socket.request.user.username + ' disconnected from chest lobby');
				console.log( game.get_status() );
				/* 2 options :
				*	- players were waiting for people
				* 	- during the game : he gives up
				*/
				
				game.remove_user(socket.player);
				
				console.log( game.get_status() );
				
			});
		});
    });
	
	// The var namespace is not really usefull
	function numClientsInRoom(namespace, room) {
		var clientsInRoom = io.nsps[namespace].adapter.rooms[room];
		var numClients = clientsInRoom === undefined ? 0 : Object.keys(clientsInRoom.sockets).length;
		return numClients;
	};

	function getPlayer(game) {
		// Get the player object of a side

		var side = game.process().turn();
		var users = game.get_users()
		var len = users.length;
		console.log(users);
        for (var i = 0; i < len; i++) {
            var player = users[i];
			console.log(player);
            if (player.team() === side) {
				console.log(player);
                return player;
            }
        }
    };
	
	function find_game(a_room) {
		// Find the game object associated yith a room
		var len = games.length;
		for (var i = 0; i < len; i++) {
			console.log(games[i].ROOM);
			if (games[i].ROOM == a_room) {
				console.log("game found");
				return (games[i]);
			};
		};
		return null;
	};
	
};





